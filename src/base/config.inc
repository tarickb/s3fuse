// this file is used to generate config.h, config.cc, s3fuse.conf, and 
// s3fuse.conf.5
//
// macros:
//
// CONFIG(type, name, default-value, description);
//   declare a configuration option.
//
// CONFIG_CONSTRAINT(test, error);
//   describe a constraint. "test" must evaluate to a boolean and can use
//   CONFIG_KEY(x) to get the value of configuration key "x". the message in
//   "error" is printed if "test" is false.
//
// CONFIG_SECTION(name);
//   declares a section (purely for formatting purposes)
//
// notes:
//   - all macro invocations must be followed by a semicolon.
//   - this file won't always be run through a preprocessor, so there's not
//     much room for variation in formatting.

CONFIG_SECTION("Required Parameters");
CONFIG(std::string, bucket_name, "", "bucket name");
CONFIG_CONSTRAINT(CONFIG_KEY(bucket_name).size() > 0, "bucket_name must be specified")
#ifndef FIXED_SERVICE
  CONFIG(std::string, service, "", "specifies the service to use -- must be one of the enabled services listed by '__PACKAGE_NAME__ -V'");
  CONFIG_CONSTRAINT(CONFIG_KEY(service).size() > 0, "service must be specified")
#endif

#ifdef WITH_AWS
  CONFIG_SECTION("AWS S3");
  CONFIG(std::string, aws_secret_file, "", "path to file containing AWS Access Key ID followed by a space followed by AWS Secret Access Key; file must not be group- or world-readable or -writable");
  CONFIG(std::string, aws_service_endpoint, "s3.amazonaws.com", "service endpoint for Amazon AWS (change to 's3-eu-west-1.amazonaws.com' for EU buckets)");
  CONFIG(bool, aws_use_ssl, true, "set to 'no'/'false' to disable SSL");
#endif

#ifdef WITH_GS
  CONFIG_SECTION("Google Storage");
  CONFIG(std::string, gs_token_file, "", "path to token file generated by __PACKAGE_NAME___gs_get_token(1); file must not be group- or world-readable or -writable");
#endif

#ifdef WITH_FVS
  CONFIG_SECTION("FV/S");
  CONFIG(std::string, fvs_secret_file, "", "path to file containing FV/S Access Key ID followed by a space followed by FV/S Secret Access Key; file must not be group- or world-readable or -writable");
  CONFIG(std::string, fvs_service_endpoint, "gss.iijgio.com", "service endpoint for IIJ FV/S");
  CONFIG(bool, fvs_use_ssl, true, "set to 'no'/'false' to disable SSL");
#endif

CONFIG_SECTION("Encryption");
CONFIG(bool, use_encryption, false, "encryption/decryption support will be enabled if set to 'true'/'yes'");
CONFIG(std::string, volume_key_id, "", "volume key identifier (required if use_encryption is 'true'/'yes')");
CONFIG(bool, encrypt_new_files, true, "all newly-created files will be encrypted if set to 'true'/'yes'");
CONFIG(std::string, volume_key_file, "", "name of file containing hex-encoded volume key. will prompt for password if blank.");

#ifdef WITH_AWS
  CONFIG_SECTION("Glacier");
  CONFIG(bool, allow_glacier_restores, false, "set to 'true'/'yes' to enable glacier object restores");
#endif

CONFIG_SECTION("Statistics");
CONFIG(std::string, stats_file, "", "write statistics on various operations and exceptions to specified file if set");

CONFIG_SECTION("Default Object Attributes");
CONFIG(int, default_uid, UID_MAX, "UID for files in S3 that don't have a UID set (defaults to process effective UID)");
CONFIG(int, default_gid, GID_MAX, "GID for files in S3 that don't have a GID set (defaults to process effective GID)");
CONFIG(int, default_mode, 0755, "mode for files in S3 that don't have a mode set");
CONFIG(std::string, default_cache_control, "", "default Cache-Control header (can be overriden with per-object extended attribute)");

CONFIG_SECTION("Object Metadata Cache Parameters");
CONFIG(int, cache_expiry_in_s, 3 * 60, "time in seconds before objects in stats cache expire");
CONFIG(bool, cache_directories, false, "cache directory listings if set to 'true'/'yes'");
CONFIG(int, max_objects_in_cache, 1000, "maximum number of objects to hold in cache");
CONFIG(bool, precache_on_readdir, true, "precache object attributes when listing directory contents (improves performance in interactive use); set to 'no'/'false' to disable");
CONFIG_CONSTRAINT(CONFIG_KEY(max_objects_in_cache) > 0, "max_objects_in_cache must be greater than zero");

CONFIG_SECTION("Local Store Parameters");
CONFIG(bool, enable_local_store_persistence, false, "keep downloaded files in local store to avoid unnecessary re-download");
CONFIG(size_t, max_local_store_size, 1000 * 1000 * 1000, "maximum local file store size (in bytes)");
CONFIG(std::string, local_store_path, "/tmp", "local store path");
CONFIG(int, local_store_purge_period, 30, "time (in seconds) between local store purge cycles");
CONFIG(bool, verify_etag_before_reopening, true, "before reopening a locally-cached file, verify that the remote etag has not changed");

CONFIG_SECTION("MIME");
CONFIG(std::string, default_content_type, "binary/octet-stream", "MIME type for newly-created objects");
CONFIG(bool, auto_detect_mime_type, true, "set file content type based on extension");

CONFIG_SECTION("Uploads/Downloads");
CONFIG(size_t, download_chunk_size, 128 * 1024, "download chunk size in bytes");
CONFIG(int, upload_chunk_size, -1, "override default upload chunk size (in bytes) (-1: use service default; 0: disable multipart uploads)");
CONFIG(int, max_transfer_retries, 5, "maximum number of times a chunk transfer will be retried before failing");
CONFIG(int, transfer_timeout_in_s, 5 * 60, "transfer timeout in seconds; should be long enough to transfer download_chunk_size/upload_chunk_size");
CONFIG(int, max_parts_in_progress, 4, "maximum number of file chunks that should be transferred at a time");
CONFIG_CONSTRAINT(CONFIG_KEY(max_transfer_retries) > 0, "max_transfer_retries must be greater than zero");
CONFIG_CONSTRAINT(CONFIG_KEY(max_parts_in_progress) > 0, "max_parts_in_progress must be greater than zero");

CONFIG_SECTION("Debug");
CONFIG(bool, verbose_requests, false, "set CURLOPT_VERBOSE (enable verbosity in libcurl) if 'yes'/'true'");

CONFIG_SECTION("Timeouts");
CONFIG(int, request_timeout_in_s, 30, "request timeout in seconds (for all HTTP requests besides transfers)");
CONFIG(int, timeout_retries, 5, "number of times to retry a request that times out (if zero; don't retry)");
CONFIG(int, max_inconsistent_state_retries, 10, "number of times to retry an operation if an inconsistent state is encountered (must be >= 2)");
CONFIG_CONSTRAINT(CONFIG_KEY(timeout_retries) >= 0, "timeout_retries must be greater than or equal to 0");
CONFIG_CONSTRAINT(CONFIG_KEY(max_inconsistent_state_retries) >= 2, "max_inconsistent_state_retries must be greater than or equal to 2");
